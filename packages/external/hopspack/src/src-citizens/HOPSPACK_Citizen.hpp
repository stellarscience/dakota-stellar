// $Id: HOPSPACK_Citizen.hpp 183 2010-12-15 18:22:41Z tplante $ 
// $URL: https://software.sandia.gov/svn/hopspack/trunk/src/src-citizens/HOPSPACK_Citizen.hpp $ 

//@HEADER
// ************************************************************************
// 
//         HOPSPACK: Hybrid Optimization Parallel Search Package
//                 Copyright 2009 Sandia Corporation
// 
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.
// 
// This file is part of HOPSPACK.
//
// HOPSPACK is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of the
// License, or (at your option) any later version.
//  
// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//  
// You should have received a copy of the GNU Lesser General Public
// License along with this library.  If not, see http://www.gnu.org/licenses/.
// 
// Questions? Contact Tammy Kolda (tgkolda@sandia.gov)
//                 or Todd Plantenga (tplante@sandia.gov) 
// 
// ************************************************************************
//@HEADER

/*!
  @file HOPSPACK_Citizen.hpp
  @brief Interface declaration for HOPSPACK::Citizen.
*/

#ifndef HOPSPACK_CITIZEN_HPP
#define HOPSPACK_CITIZEN_HPP

#include "HOPSPACK_common.hpp"
#include "HOPSPACK_CallbackToMediator.hpp"
#include "HOPSPACK_DataPoint.hpp"
#include "HOPSPACK_LinConstr.hpp"
#include "HOPSPACK_ParameterList.hpp"
#include "HOPSPACK_ProblemDef.hpp"

namespace HOPSPACK
{


//----------------------------------------------------------------------
//! Interface that uses evaluated points to solve an optimization problem.
/*! Citizens communicate with the Mediator, exchanging new trial points
 *  for evaluated ones.  Evaluation requests from all citizens are combined
 *  and ordered according to citizen priority and the order of new points
 *  generated by each citizen.
 *
 *  When the Mediator calls a citizen method, all main thread processing
 *  by HOPSPACK waits for the method to return.  Therefore, a citizen method
 *  requiring excessive CPU time should offload the work to an asynchronous
 *  citizen worker.
 *
 *  An interface design makes it easy for users to extend HOPSPACK with their
 *  own Citizen implementation.  New implementations must subclass Citizen,
 *  and become registered by modifying one of the "newInstance" methods.
 */
//----------------------------------------------------------------------
class Citizen
{
  public:

    //! Current state of the citizen.
    enum State
    {
        //! Citizen wishes to continue.
        CONTINUE = 1,

        //! Citizen is probably finished, still wants exchange() to be called.
        WAITING,

        //! Citizen is finished, does not want exchange() to be called again.
        FINISHED,

        //! Child citizen is finished, waiting for postProcess() to be called.
        CHILD_WAITING,

        //! Child citizen is finished, ready for Mediator to destroy it.
        CHILD_FINISHED,

        //! Citizen demands that all HOPSPACK processing stop.
        MUST_STOP
    };


    //! Factory method for constructing a citizen instance.
    /*!
     *  Set pCallback to NULL if the instance does not create children.
     *  Set pParent to NULL if the instance is not a child.
     *
     *  @param[in] nIdNumber   Unique HOPSPACK ID number of the citizen.
     *  @param[in] sName       Name of the citizen.
     *  @param[in] cParams     Sublist of user input parameters for this citizen.
     *  @param[in] cProbDef    Problem definition.
     *  @param[in] cLinConstr  Linear constraints definition.
     *  @param[in] pCallback   Interface for dynamically adding child citizens,
     *                         or NULL if the instance does not create children.
     *  @param[in] pParent     Pointer to parent for calling back, or NULL
     *                         if this is not a child citizen.
     *  @return                New Citizen instance if successful, else NULL.
     *                         Caller must delete the instance when finished.
     */
    static Citizen *  newInstance
        (const int                         nIdNumber,
         const string             &        sName,
         const ParameterList      &        cParams,
         const ProblemDef         &        cProbDef,
         const LinConstr          &        cLinConstr,
               CallbackToMediator * const  pCallback,
               Citizen            * const  pParent);

    //! Destructor.
    virtual ~Citizen (void) = 0;


    //! Called once by the Mediator prior to processing points by any citizen.
    virtual void  preProcess (void) = 0;

    //! Called once by the Mediator after processing points by all citizens.
    /*!
     *  Typically, a citizen will display its state and the best point found.
     *  A dynamically created child citizen should make the callback to its
     *  parent here.
     */
    virtual void  postProcess (void) = 0;

    //! Exchange a list of evaluated points for a list of new trial points.
    /*!
     *  The citizen sees all new result points since the last call to this
     *  method.  The "exchange" happens implicitly:  after all citizens have
     *  viewed the newly evaluated points, then the Mediator erases them.
     *  The cOwnerTags parameter allows the citizen to find the subset
     *  of results matching previous requests that it made.
     *
     *  @param[in] cReturnList  Input list of newly evaluated points.
     *  @param[in] cOwnerTags   List containing the tags of points in cReturnList
     *                          that this citizen owns.
     *  @param[out] cWaitList   Output list of trial points that will be added
     *                          to the wait queue.  Points will be evaluated
     *                          in this order, starting from the back.
     */
    virtual void  exchange (const list< DataPoint * > &  cReturnList,
                            const list< int >         &  cOwnerTags,
                                  list< DataPoint * > &  cWaitList) = 0;

    //! Mark the child to exit as soon as possible.
    /*!
     *  Called by the Mediator when it plans to ignore trial points; for
     *  example, if an Objective Target value has been reached by some point.
     *  The Mediator may make one more call to the exchange() method,
     *  but the citizen should not waste effort adding trial points,
     *  because they will not be evaluated.
     */
    virtual void  setEarlyExit (void);

    //! Return the unique ID number of the citizen.
    virtual int  getIdNumber (void) const = 0;

    //! Return the unique name of the citizen (parameter name plus ID).
    virtual const string &  getName (void) const = 0;

    //! Return the current state of the citizen.
    virtual State  getState (void) const = 0;

    //! Child citizen calls back to its parent citizen when finished.
    /*!
     *  If a citizen can dynamically spawn a child citizen, then it implements
     *  this method.  The child will call the method when it is finished.
     *  Typically, the parent citizen uses a child to solve a subproblem.
     *
     *  @param[in] nIdNumber    Unique HOPSPACK ID number of the child instance
     *                          that is calling back.
     *  @param[in] nReturnCode  The meaning of return codes is defined jointly
     *                          by a parent / child pair.
     *  @param[in] cFinalPoint  Solution point returned by the child.
     *  @param[in] nTotalEvals  Evaluations made by the child citizen.
     *                          The number does not include points that were
     *                          "evaluated" from the cache.
     */
    virtual void  callbackFromChild (const int          nIdNumber,
                                     const int          nReturnCode,
                                     const DataPoint &  cFinalPoint,
                                     const int          nTotalEvals);

    //! Return the priority of this citizen (supplied in parameter list).
    /*!
     *  Priorities must be positive integers between 1 and 10.
     *  The highest priority is 1.  Trial points requested by a call to
     *  this citizen's exchange() method will be evaluated before points from
     *  a lower priority citizen.
     */
    int  getPriority (void) const;

    //! Return true if the citizen should ignore evaluated points from others.
    /*!
     *  The method returns a value set by parameter "Ignore Other Points".
     *  The value should determine if the exchange() method of this citizen
     *  can look at other citizen points.  Citizens always receive every point
     *  in exchange(), so enforcement of the rule is left to the subclass
     *  implementation.
     */
    bool  shouldIgnoreOtherPoints (void) const;


  protected:

    //! Subclasses should call this base class constructor.
    /*!
     *  The method parses parameters that are common to all citizens:
     *    "Priority"            - access using getPriority()
     *    "Ignore Other Points" - access using shouldIgnoreOtherPoints()
     */
    Citizen (const ParameterList &  cParams,
             const string        &  sName);


  private:

    //! Default constructor is hidden, forcing callers to use factory method.
    Citizen (void);

    //! Helper method to construct a citizen instance using the parent type.
    /*!
     *  @param[in] sCtznType   Parameter "Type".
     *  @param[in] nIdNumber   Unique HOPSPACK ID number of the citizen.
     *  @param[in] sName       Name of the citizen.
     *  @param[in] cParams     Sublist of user input parameters for this citizen.
     *  @param[in] cProbDef    Problem definition.
     *  @param[in] cLinConstr  Linear constraints definition.
     *  @param[in] pCallback   Interface for dynamically adding child citizens,
     *                         or NULL if the instance does not create children.
     *  @return                New Citizen instance if successful, else NULL.
     */
    static Citizen *  makeNewParentInstance_
        (const string             &        sCtznType,
         const int                         nIdNumber,
         const string             &        sName,
         const ParameterList      &        cParams,
         const ProblemDef         &        cProbDef,
         const LinConstr          &        cLinConstr,
               CallbackToMediator * const  pCallback);

    //! Helper method to construct a citizen instance using the child type.
    /*!
     *  @param[in] sCtznType   Parameter "Type".
     *  @param[in] nIdNumber   Unique HOPSPACK ID number of the citizen.
     *  @param[in] sName       Name of the citizen.
     *  @param[in] cParams     Sublist of user input parameters for this citizen.
     *  @param[in] cProbDef    Problem definition.
     *  @param[in] cLinConstr  Linear constraints definition.
     *  @param[in] pCallback   Interface for dynamically adding child citizens,
     *                         or NULL if the instance does not create children.
     *  @param[in] pParent     Pointer to parent for calling back.
     *  @return                New Citizen instance if successful, else NULL.
     */
    static Citizen *  makeNewChildInstance_
        (const string             &        sCtznType,
         const int                         nIdNumber,
         const string             &        sName,
         const ParameterList      &        cParams,
         const ProblemDef         &        cProbDef,
         const LinConstr          &        cLinConstr,
               CallbackToMediator * const  pCallback,
               Citizen            * const  pParent);


    //! Priority level, from 1 to 10 where 1 is highest priority.
    int  _nPriority;

    //! True means the citizen should ignore evaluated points from others.
    bool  _bShouldIgnoreOtherPoints;
};

}          //-- namespace HOPSPACK

#endif     //-- HOPSPACK_CITIZEN_HPP
